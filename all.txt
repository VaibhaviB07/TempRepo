*****************************************NON-AI TIC TAC TOE**************************************
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <time.h>

int TURN = 1; // Tracks the current turn
int BOARD[9] ={2, 2, 2, 2, 2, 2, 2, 2, 2}; // Represents the Tic-Tac-Toe board, initialized to empty

// Function to determine the position to place a '2'
int Make2(){
    if(BOARD[4] == 2){
        return 4; // If center is available, return center position
    }
    else{
        // Otherwise, randomly select a corner
        int l = 1, u = 4;
        srand(time(NULL));
        int idx = 2 + 2 * (rand() % 4); // Generate random index for corner position
        printf("Make2() random number : %d\n", idx - 1);
        if(BOARD[idx - 1] == 2){
            return idx - 1; // If selected position is empty, return it
        }
        else{
            return -1; // If selected position is not empty, return -1
        }
    }
}

// Function to make a move on the board
void GO(int n){
    if(TURN % 2 == 0){
        BOARD[n] = 5; // If TURN is even, place 'O' (5) on the board
    }
    else{
        BOARD[n] = 3; // If TURN is odd, place 'X' (3) on the board
    }
    TURN++; // Increment TURN after making a move
}

// Function to check for possible win positions
int POSSWIN(char P){
    if(P == 'X'){
        //Row check
        for (int i = 0; i < 9; i += 3) {
            if (BOARD[i] * BOARD[i + 1] * BOARD[i + 2] == 18) {
                for (int j = i; j < i + 3; j++) {
                    if (BOARD[j] == 2)
                        return j; // Return empty position in winning row 
                }
            }
        }

        //Column check
        for (int i = 0; i < 3; i++) {
            if (BOARD[i] * BOARD[i + 3] * BOARD[i + 6] == 18) {
                for (int j = i; j < 9; j += 3) {
                    if (BOARD[j] == 2)
                        return j; // Return empty position in winning column
                }
            }
        }

        //Diagonal check
        if (BOARD[0] * BOARD[4] * BOARD[8] == 18) {
            for (int i = 0; i < 9; i += 4) {
                if (BOARD[i] == 2)
                    return i; 
            }
        }

        if (BOARD[2] * BOARD[4] * BOARD[6] == 18) {
            for (int i = 2; i < 7; i += 2) {
                if (BOARD[i] == 2)
                    return i; // Return empty position in first diagonal
            }
        }
    }
    if(P == 'O'){
        // Similar checks for 'O' as above, 
        // but looking for potential 'O' win positions (product equals 50)
        for (int i = 0; i < 9; i += 3) {
            if (BOARD[i] * BOARD[i + 1] * BOARD[i + 2] == 50) {
                for (int j = i; j < i + 3; j++) {
                    if (BOARD[j] == 2)
                        return j;  
                }
            }
        }

        for (int i = 0; i < 3; i++) {
            if (BOARD[i] * BOARD[i + 3] * BOARD[i + 6] == 50) {
                for (int j = i; j < 9; j += 3) {
                    if (BOARD[j] == 2)
                        return j;  
                }
            }
        }

        if (BOARD[0] * BOARD[4] * BOARD[8] == 50) {
            for (int i = 0; i < 9; i += 4) {
                if (BOARD[i] == 2)
                    return i; 
            }
        }

        if (BOARD[2] * BOARD[4] * BOARD[6] == 50) {
            for (int i = 2; i < 7; i += 2) {
                if (BOARD[i] == 2)
                    return i;  
            }
        }
    }

    return 0; // Return 0 if no potential win positions found
}

// Function to print the Tic-Tac-Toe grid
void printGrid(){
    printf("The Tic-Tac-Toe Grid at TURN:%d => \n", TURN-1);
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", BOARD[i * 3 + j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main() {
    int OP, OP1, OP2;
    printGrid();

    //Applying logic for each turn using Switch-Case statements
    //Even Turn - O Plays
    //Odd Turn - X Plays
    while(TURN <= 9) {
        switch (TURN) {
            case 1:
                GO(0);
                printGrid();
                break;
            case 2:
                if(BOARD[4] == 2)
                    GO(4);
                else
                    GO(1);
                printGrid();
                break;
            case 3:
                if(BOARD[8] == 2)
                    GO(8);
                else
                    GO(3);
                printGrid();
                break;
            case 4:
                OP = POSSWIN('X');
                if(OP != 0)
                    GO(OP);
                else
                    GO(Make2());
                printGrid();
                break;
            case 5:
                OP1 = POSSWIN('X'), OP2 = POSSWIN('O');
                if(OP1 != 0)
                    GO(OP1);
                else if(OP2 != 0)
                    GO(OP2);
                else if(BOARD[6] == 2)
                    GO(6);
                else
                    GO(2);
                printGrid();
                break;
            case 6:
                OP1 = POSSWIN('X'), OP2 = POSSWIN('O');
                if(OP2 != 0)
                    GO(OP2);
                else if(OP1 != 0)
                    GO(OP1);
                else
                    GO(Make2());
                printGrid();
                break;
            case 7:
                OP1 = POSSWIN('X'), OP2 = POSSWIN('O');
                if(OP1 != 0)
                    GO(OP1);
                else if(OP2 != 0)
                    GO(OP2);
                else{
                    srand(time(NULL));
                    int random = 1;
                    while(BOARD[random] != 2){
                        random = 2 + rand() % 8;
                    }
                    printf("Random Number Generated at TURN:7 = %d\n", random);
                    BOARD[random] = 3;
                    TURN++;
                }
                printGrid();
                break;
            case 8:
                OP1 = POSSWIN('X'), OP2 = POSSWIN('O');
                if(OP2 != 0)
                    GO(OP2);
                else if(OP1 != 0)
                    GO(OP1);
                else{
                    srand(time(NULL));
                    int random = 1;
                    while(BOARD[random] != 2){
                        random = 2 + rand() % 8;
                    }
                    printf("Random Number Generated at TURN:8 = %d\n", random);
                    BOARD[random] = 5;
                    TURN++;
                }
                printGrid();
                break;
            case 9:
                OP1 = POSSWIN('X'), OP2 = POSSWIN('O');
                if(OP1 != 0)
                    GO(OP1);
                else if(OP2 != 0)
                    GO(OP2);
                else{
                    srand(time(NULL));
                    int random = 1;
                    while(BOARD[random] != 2){
                        random = 2 + rand() % 8;
                    }
                    printf("Random Number Generated at TURN:9 = %d\n", random);
                    BOARD[random] = 3;
                    TURN++;
                }
                printGrid();
                break;
            default:
                printf("Invalid Turn !!");
                break;
        }
    }

    return 0;
}

********************************************************AI TIC TAC TOE************************************************************
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define COMPUTER 1 
#define HUMAN 2 

#define SIDE 3 // Length of the board 

// Computer will move with 'O' 
// and human with 'X' 
#define COMPUTERMOVE 'O' 
#define HUMANMOVE 'X' 

// A function to show the current board status 
void showBoard(char board[][SIDE]) 
{ 
	
	printf("\t\t\t %c | %c | %c \n", board[0][0], board[0][1], board[0][2]); 
	printf("\t\t\t-----------\n"); 
	printf("\t\t\t %c | %c | %c \n", board[1][0], board[1][1], board[1][2]); 
	printf("\t\t\t-----------\n"); 
	printf("\t\t\t %c | %c | %c \n\n", board[2][0], board[2][1], board[2][2]);  
} 

// A function to show the instructions 
void showInstructions() 
{ 
	printf("\nChoose a cell numbered from 1 to 9 as below and play\n\n"); 
	
	printf("\t\t\t 1 | 2 | 3 \n"); 
	printf("\t\t\t-----------\n"); 
	printf("\t\t\t 4 | 5 | 6 \n"); 
	printf("\t\t\t-----------\n"); 
	printf("\t\t\t 7 | 8 | 9 \n\n"); 
} 


// A function to initialise the game 
void initialise(char board[][SIDE]) 
{	
	// Initially the board is empty 
	for (int i=0; i<SIDE; i++) 
	{ 
		for (int j=0; j<SIDE; j++) 
			board[i][j] = ' '; 
	} 
} 

// A function to declare the winner of the game 
void declareWinner(int whoseTurn) 
{ 
	if (whoseTurn == COMPUTER) 
		printf("COMPUTER has won\n"); 
	else
		printf("HUMAN has won\n"); 
} 

// A function that returns true if any of the row 
// is crossed with the same player's move 
bool rowCrossed(char board[][SIDE]) 
{ 
	for (int i=0; i<SIDE; i++) 
	{ 
		if (board[i][0] == board[i][1] && 
			board[i][1] == board[i][2] && 
			board[i][0] != ' ') 
			return (true); 
	} 
	return(false); 
} 

// A function that returns true if any of the column 
// is crossed with the same player's move 
bool columnCrossed(char board[][SIDE]) 
{ 
	for (int i=0; i<SIDE; i++) 
	{ 
		if (board[0][i] == board[1][i] && 
			board[1][i] == board[2][i] && 
			board[0][i] != ' ') 
			return (true); 
	} 
	return(false); 
} 

// A function that returns true if any of the diagonal 
// is crossed with the same player's move 
bool diagonalCrossed(char board[][SIDE]) 
{ 
	if (board[0][0] == board[1][1] && 
		board[1][1] == board[2][2] && 
		board[0][0] != ' ') 
		return(true); 
		
	if (board[0][2] == board[1][1] && 
		board[1][1] == board[2][0] && 
		board[0][2] != ' ') 
		return(true); 

	return(false); 
} 

// A function that returns true if the game is over 
// else it returns a false 
bool gameOver(char board[][SIDE]) 
{ 
	return(rowCrossed(board) || columnCrossed(board) || diagonalCrossed(board) ); 
}

// Function to calculate best score
int minimax(char board[][SIDE], int depth, bool isAI)
{
	int score = 0;
	int bestScore = 0;
	if (gameOver(board) == true)
	{
		if (isAI == true)
			return -1;
		if (isAI == false)
			return +1;
	}
	else
	{
		if(depth < 9)
		{
			if(isAI == true)
			{
				bestScore = -999;
				for(int i=0; i<SIDE; i++)
				{
					for(int j=0; j<SIDE; j++)
					{
						if (board[i][j] == ' ')
						{
							board[i][j] = COMPUTERMOVE;
							score = minimax(board, depth + 1, false);
							board[i][j] = ' ';
							if(score > bestScore)
							{
								bestScore = score;
							}
						}
					}
				}
				return bestScore;
			}
			else
			{
				bestScore = 999;
				for (int i = 0; i < SIDE; i++)
				{
					for (int j = 0; j < SIDE; j++)
					{
						if (board[i][j] == ' ')
						{
							board[i][j] = HUMANMOVE;
							score = minimax(board, depth + 1, true);
							board[i][j] = ' ';
							if (score < bestScore)
							{
								bestScore = score;
							}
						}
					}
				}
				return bestScore;
			}
		}
		else
		{
			return 0;
		}
	}
	return 0;
}

// Function to calculate best move
int bestMove(char board[][SIDE], int moveIndex)
{
	int x = -1, y = -1;
	int score = 0, bestScore = -999;
	for (int i = 0; i < SIDE; i++)
	{
		for (int j = 0; j < SIDE; j++)
		{
			if (board[i][j] == ' ')
			{
				board[i][j] = COMPUTERMOVE;
				score = minimax(board, moveIndex+1, false);
				board[i][j] = ' ';
				if(score > bestScore)
				{
					bestScore = score;
					x = i;
					y = j;
				}
			}
		}
	}
	return x*3+y;
}

// A function to play Tic-Tac-Toe 
void playTicTacToe(int whoseTurn) 
{ 
	char board[SIDE][SIDE]; 
	int moveIndex = 0, x = 0, y = 0;

	initialise(board);
	showInstructions(); 
	
	// Keep playing till the game is over or it is a draw 
	while (gameOver(board) == false && moveIndex != SIDE*SIDE) 
	{ 
		int n;
		if (whoseTurn == COMPUTER) 
		{
			n = bestMove(board, moveIndex);
			x = n / SIDE;
			y = n % SIDE;
			board[x][y] = COMPUTERMOVE; 
			printf("COMPUTER has put a %c in cell %d\n\n", COMPUTERMOVE, n+1);
			showBoard(board);
			moveIndex ++; 
			whoseTurn = HUMAN;
		} 
		
		else if (whoseTurn == HUMAN) 
		{
			printf("You can insert in the following positions : ");
			for(int i=0; i<SIDE; i++)
				for (int j = 0; j < SIDE; j++)
					if (board[i][j] == ' ')
						printf("%d ", (i * 3 + j) + 1);
			printf("\n\nEnter the position = ");
			scanf("%d",&n);
			n--;
			x = n / SIDE;
			y = n % SIDE; 
			if(board[x][y] == ' ' && n<9 && n>=0)
			{
				board[x][y] = HUMANMOVE; 
				printf ("\nHUMAN has put a %c in cell %d\n\n", HUMANMOVE, n+1); 
				showBoard(board); 
				moveIndex ++; 
				whoseTurn = COMPUTER;
			}
			else if(board[x][y] != ' ' && n<9 && n>=0)
			{
				printf("\nPosition is occupied, select any one place from the available places\n\n");
			}
			else if(n<0 || n>8)
			{
				printf("Invalid position\n");
			}
		} 
	} 

	// If the game has drawn 
	if (gameOver(board) == false && moveIndex == SIDE * SIDE) 
		printf("It's a draw\n"); 
	else
	{ 
		// Toggling the user to declare the actual winner 
		if (whoseTurn == COMPUTER) 
			whoseTurn = HUMAN; 
		else if (whoseTurn == HUMAN) 
			whoseTurn = COMPUTER; 
		
		declareWinner(whoseTurn); 
	} 
} 

int main() 
{ 
	printf("\n-------------------------------------------------------------------\n\n");
	printf("\t\t\t Tic-Tac-Toe\n"); 
	printf("\n-------------------------------------------------------------------\n\n");
	char cont='y';
	do {
		char choice;
	 	printf("Do you want to start first?(y/n) : ");
	 	scanf(" %c", &choice);

		if(choice=='n')
			playTicTacToe(COMPUTER);
		else if(choice=='y')
			playTicTacToe(HUMAN);
		else
			printf("Invalid choice\n"); 
        
		printf("\nDo you want to quit(y/n) : ");
       		scanf(" %c", &cont);
	} while(cont=='n');
	return (0); 
} 

*******************************************************************8 PUZZLE BFS******************************************************************************
#include <bits/stdc++.h>
using namespace std;

bool checkEqual(vector<vector<int>> curr, vector<vector<int>> final)
{
   for (int i = 0; i < 3; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         if (curr[i][j] != final[i][j])
            return false;
      }
   }
   return true;
}

pair<int, int> findBlank(vector<vector<int>> vec)
{
   pair<int, int> ans;
   for (int i = 0; i < 3; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         if (vec[i][j] == 0)
            ans = {i, j};
      }
   }
   return ans;
}

void printAns(vector<vector<vector<int>>> vec)
{
   for (auto mat : vec)
   {
      for (auto row : mat)
      {
         for (auto el : row)
         {
            cout << el << " ";
         }
         cout << endl;
      }
      cout << endl;
   }
}

int main()
{
   vector<vector<int>> start = {{2, 8, 3},
                                {1, 6, 4},
                                {7, 0, 5}};
   vector<vector<int>> final = {{1, 2, 3},
                                {8, 0, 4},
                                {7, 6, 5}};
   vector<vector<vector<int>>> ans;
   queue<pair<vector<vector<int>>, vector<vector<vector<int>>>>> q;
   q.push({start, ans});
   //              R  D   L  U
   int delrow[] = {0, 1, 0, -1};
   int delcol[] = {1, 0, -1, 0};
   while (!q.empty())
   {
      bool flag = false;
      int size = q.size();
      while (size--)
      {
         vector<vector<int>> curr = q.front().first;
         vector<vector<vector<int>>> vec = q.front().second;
         q.pop();
         if (checkEqual(curr, final))
         {
            cout << "Possible solution:" << endl
                 << endl;
            printAns(vec);
            flag = true;
            break;
         }
         pair<int, int> blank = findBlank(curr);
         int row = blank.first;
         int col = blank.second;
         for (int i = 0; i < 4; i++)
         {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
            if (nrow >= 0 && nrow < 3 && ncol >= 0 && ncol < 3)
            {
               swap(curr[row][col], curr[nrow][ncol]);
               vec.push_back(curr);
               q.push({curr, vec});
               vec.pop_back();
               swap(curr[row][col], curr[nrow][ncol]);
            }
         }
      }
      if (flag)
         break;
   }
   return 0;
}

*****************************************8 PUZZLE DFS********************************************
#include <bits/stdc++.h>
using namespace std;

bool checkEqual(vector<vector<int>> &curr, vector<vector<int>> &final)
{
   return curr == final;
}

void findBlank(vector<vector<int>> curr, int &row, int &col)
{
   for (int i = 0; i < 3; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         if (curr[i][j] == 0)
         {
            row = i;
            col = j;
            return;
         }
      }
   }
}

void printAns(vector<vector<vector<int>>> vec)
{
   for (auto mat : vec)
   {
      for (auto row : mat)
      {
         for (auto el : row)
         {
            cout << el << " ";
         }
         cout << endl;
      }
      cout << endl;
   }
}

bool dfs(vector<vector<int>> &curr, vector<vector<int>> &final, int depth, int row, int col, set<vector<vector<int>>> &vis, vector<vector<vector<int>>> &vec)
{
   if (depth > 10)
      return false;

   vec.push_back(curr);
   vis.insert(curr);

   if (checkEqual(curr, final))
   {
      cout << "Possible solution:" << endl
           << endl;
      printAns(vec);
      return true;
   }

   int delrow[] = {0, 0, -1, 1};
   int delcol[] = {1, -1, 0, 0};

   for (int i = 0; i < 4; i++)
   {
      int nrow = row + delrow[i];
      int ncol = col + delcol[i];

      if (nrow >= 0 && nrow < 3 && ncol >= 0 && ncol < 3)
      {
         swap(curr[row][col], curr[nrow][ncol]);
         if (!vis.count(curr))
         {
            if (dfs(curr, final, depth + 1, nrow, ncol, vis, vec))
               return true;
         }
         swap(curr[row][col], curr[nrow][ncol]);
      }
   }
   vec.pop_back();

   return false;
}

int main()
{
   vector<vector<int>> start = {{2, 8, 3},
                                {1, 6, 4},
                                {7, 0, 5}};
   vector<vector<int>> final = {{1, 2, 3},
                                {8, 0, 4},
                                {7, 6, 5}};

   int row, col;
   findBlank(start, row, col);
   vector<vector<vector<int>>> ans;
   set<vector<vector<int>>> vis;
   if (!dfs(start, final, 0, row, col, vis, ans))
      cout << "No possible solution." << endl;

   return 0;
}


*****************************************8 PUZZLE (A*)**********************************
#include <bits/stdc++.h>
using namespace std;

int countMisplaced(vector<vector<int>> &curr, vector<vector<int>> &final)
{
    int count = 0;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (curr[i][j] != 0 && curr[i][j] != final[i][j])
                count++;
        }
    }
    return count;
}

pair<int, int> findBlank(vector<vector<int>> vec)
{
    pair<int, int> ans;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (vec[i][j] == 0)
                ans = {i, j};
        }
    }
    return ans;
}

void printState(vector<vector<int>> state)
{
    for (auto row : state)
    {
        for (auto el : row)
        {
            cout << el << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int main()
{
    vector<vector<int>> start = {{2, 8, 3},
                                 {1, 6, 4},
                                 {7, 0, 5}};
    vector<vector<int>> final = {{1, 2, 3},
                                 {8, 0, 4},
                                 {7, 6, 5}};

    priority_queue<pair<int, vector<vector<int>>>, vector<pair<int, vector<vector<int>>>>, greater<>> pq;
    int h = countMisplaced(start, final);
    int g = 0;
    pq.push({g + h, start});

    //              R  D   L  U
    int delrow[] = {0, 1, 0, -1};
    int delcol[] = {1, 0, -1, 0};

    while (!pq.empty())
    {
        vector<vector<int>> curr = pq.top().second;
        pq.pop();
        printState(curr);

        h = countMisplaced(curr, final);
        cout << "g = " << g << endl;
        cout << "h = " << h << endl
             << endl;

        if (h == 0)
        {
            cout << "Solution found!" << endl;
            break;
        }

        g++;

        pair<int, int> blank = findBlank(curr);
        int row = blank.first;
        int col = blank.second;

        for (int i = 0; i < 4; i++)
        {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
            if (nrow >= 0 && nrow < 3 && ncol >= 0 && ncol < 3)
            {
                swap(curr[row][col], curr[nrow][ncol]);
                h = countMisplaced(curr, final);
                pq.push({g + h, curr});
                swap(curr[row][col], curr[nrow][ncol]);
            }
        }
    }
    return 0;
}

*********************************8 PUZZLE BEST FIRST SEARCH ***********************************
#include <bits/stdc++.h>
using namespace std;

int countMisplaced(vector<vector<int>> &curr, vector<vector<int>> &final)
{
    int count = 0;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (curr[i][j] != 0 && curr[i][j] != final[i][j])
                count++;
        }
    }
    return count;
}

pair<int, int> findBlank(vector<vector<int>> vec)
{
    pair<int, int> ans;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (vec[i][j] == 0)
                ans = {i, j};
        }
    }
    return ans;
}

void printState(vector<vector<int>> state)
{
    for (auto row : state)
    {
        for (auto el : row)
        {
            cout << el << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int main()
{
    vector<vector<int>> start = {{2, 8, 3},
                                 {1, 6, 4},
                                 {7, 0, 5}};
    vector<vector<int>> final = {{1, 2, 3},
                                 {8, 0, 4},
                                 {7, 6, 5}};

    priority_queue<pair<int, vector<vector<int>>>, vector<pair<int, vector<vector<int>>>>, greater<>> pq;
    int h = countMisplaced(start, final);
    pq.push({h, start});

    //              R  D   L  U
    int delrow[] = {0, 1, 0, -1};
    int delcol[] = {1, 0, -1, 0};

    while (!pq.empty())
    {
        vector<vector<int>> curr = pq.top().second;
        pq.pop();
        printState(curr);

        h = countMisplaced(curr, final);
        cout << "h = " << h << endl
             << endl;

        if (h == 0)
        {
            cout << "Solution found!" << endl;
            break;
        }

        pair<int, int> blank = findBlank(curr);
        int row = blank.first;
        int col = blank.second;

        for (int i = 0; i < 4; i++)
        {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
            if (nrow >= 0 && nrow < 3 && ncol >= 0 && ncol < 3)
            {
                swap(curr[row][col], curr[nrow][ncol]);
                h = countMisplaced(curr, final);
                pq.push({h, curr});
                swap(curr[row][col], curr[nrow][ncol]);
            }
        }
    }
    return 0;
}

***************************************************************N-QUEENS CSP*************************************************
#include <bits/stdc++.h>
using namespace std;

void printBoard(vector<vector<int>> &board)
{
    for (auto row : board)
    {
        for (auto i : row)
            cout << i << " ";
        cout << endl;
    }
    cout << endl;
}

bool isSafe(int row, int col, vector<vector<int>> &board, int n)
{
    int x = row;
    int y = col;
    while (y >= 0)
    {
        if (board[x][y] == 1)
            return false;
        y--;
    }
    x = row;
    y = col;
    while (x >= 0 && y >= 0)
    {
        if (board[x][y] == 1)
            return false;
        x--;
        y--;
    }
    x = row;
    y = col;
    while (x < n && y >= 0)
    {
        if (board[x][y] == 1)
            return false;
        x++;
        y--;
    }
    return true;
}

void nQueens(int col, vector<vector<int>> &board, int n, bool &flag)
{
    if (col == n)
    {
        flag = true;
        printBoard(board);
        return;
    }
    for (int row = 0; row < n; row++)
    {
        if (isSafe(row, col, board, n))
        {
            board[row][col] = 1;
            nQueens(col + 1, board, n, flag);
            board[row][col] = 0;
        }
    }
}

int main()
{
    int n;
    cin >> n;
    bool flag = false;

    vector<vector<int>> board(n, vector<int>(n, 0));
    nQueens(0, board, n, flag);

    if (!flag)
        cout << "No solution found" << endl;
    return 0;
}

****************(AO*)************************************
import java.util.*;

public class AO {
public static Map<String, Integer>
	Cost(Map<String, Integer> H,
		Map<String, List<String> > condition, int weight)
{
	Map<String, Integer> cost = new HashMap<>();
	if (condition.containsKey("AND")) {
	List<String> AND_nodes = condition.get("AND");
	String Path_A = String.join(" AND ", AND_nodes);
	int PathA
		= AND_nodes.stream()
		.mapToInt(
		node -> H.get(node) + weight)
		.sum();
	cost.put(Path_A, PathA);
	}
	if (condition.containsKey("OR")) {
	List<String> OR_nodes = condition.get("OR");
	String Path_B = String.join(" OR ", OR_nodes);
	int PathB
		= OR_nodes.stream()
		.mapToInt(
		node -> H.get(node) + weight)
		.min()
		.getAsInt();
	cost.put(Path_B, PathB);
	}
	return cost;
}

public static Map<String, Map<String, Integer> >
	UpdateCost(
	Map<String, Integer> H,
	Map<String, Map<String, List<String> > > Conditions,
	int weight)
{
	List<String> Main_nodes
	= new ArrayList<>(Conditions.keySet());
	Collections.reverse(Main_nodes);
	Map<String, Map<String, Integer> > least_cost
	= new HashMap<>();
	for (String key : Main_nodes) {
	Map<String, List<String> > condition
		= Conditions.get(key);
	System.out.printf("%s: %s >>> %s%n", key,
						condition,
						Cost(H, condition, weight));
	Map<String, Integer> c
		= Cost(H, condition, weight);
	H.put(key, Collections.min(c.values()));
	least_cost.put(key, Cost(H, condition, weight));
	}
	return least_cost;
}

public static String ShortestPath(
	String Start,
	Map<String, Map<String, Integer> > Updated_cost,
	Map<String, Integer> H)
{
	String Path = Start;
	if (Updated_cost.containsKey(Start)) {
	int Min_cost = Collections.min(
		Updated_cost.get(Start).values());
	List<String> key = new ArrayList<>(
		Updated_cost.get(Start).keySet());
	List<Integer> values = new ArrayList<>(
		Updated_cost.get(Start).values());
	int Index = values.indexOf(Min_cost);
	List<String> Next
		= Arrays.asList(key.get(Index).split(" "));
	if (Next.size() == 1) {
		Start = Next.get(0);
		Path += "<--"
		+ ShortestPath(Start, Updated_cost,
						H);
	}
	else {
		Path += "<--(" + key.get(Index) + ") ";
		Start = Next.get(0);
		Path += "["
		+ ShortestPath(Start, Updated_cost,
						H)
		+ " + ";
		Start = Next.get(Next.size() - 1);
		Path += ShortestPath(Start, Updated_cost, H)
		+ "]";
	}
	}
	return Path;
}

public static void main(String[] args)
{
	Map<String, Integer> H = new HashMap<>();
	H.put("A", -1);
	H.put("B", 5);
	H.put("C", 2);
	H.put("D", 4);
	H.put("E", 7);
	H.put("F", 9);
	H.put("G", 3);
	H.put("H", 0);
	H.put("I", 0);
	H.put("J", 0);

	Map<String, Map<String, List<String> > > Conditions
	= new HashMap<>();
	Map<String, List<String> > aConditions
	= new HashMap<>();
	aConditions.put("OR", Arrays.asList("B"));
	aConditions.put("AND", Arrays.asList("C", "D"));
	Conditions.put("A", aConditions);
	Map<String, List<String> > bConditions
	= new HashMap<>();
	bConditions.put("OR", Arrays.asList("E", "F"));
	Conditions.put("B", bConditions);

	Map<String, List<String> > cConditions
	= new HashMap<>();
	cConditions.put("OR", Arrays.asList("G"));
	cConditions.put("AND", Arrays.asList("H", "I"));
	Conditions.put("C", cConditions);

	Map<String, List<String> > dConditions
	= new HashMap<>();
	dConditions.put("OR", Arrays.asList("J"));
	Conditions.put("D", dConditions);

	// weight
	int weight = 1;

	// Updated cost
	System.out.println("Updated Cost :");
	Map<String, Map<String, Integer> > Updated_cost
	= UpdateCost(H, Conditions, weight);
	System.out.println("*".repeat(75));
	System.out.println("Shortest Path :");
	System.out.println(
	ShortestPath("A", Updated_cost, H));
}
}


****************************iterative dfs*******************************
import java.util.*;

public class dfs {

    public static int total = 0;

    static class Node {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static Stack<Node> result = new Stack<>();
    static boolean vis[][] = new boolean[5][5];

    static boolean solveDfs(int curj1, int curj2, int jug1, int jug2, int target, int depth, int maxDepth) {
        if (depth > maxDepth) {
            return false;
        }

        if (curj1 == target || curj2 == target) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        if (vis[curj1][curj2]) {
            return false;
        }

        vis[curj1][curj2] = true;
        total++;

        // Try all possible moves

        // Fill jug1
        if (curj1 < jug1 && solveDfs(jug1, curj2, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Fill jug2
        if (curj2 < jug2 && solveDfs(curj1, jug2, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Empty jug1
        if (curj1 > 0 && solveDfs(0, curj2, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Empty jug2
        if (curj2 > 0 && solveDfs(curj1, 0, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Transfer from jug1 to jug2
        if (curj1 > 0 && curj2 < jug2) {
            boolean temp;
            if (curj1 + curj2 <= jug2) {
                temp = solveDfs(0, curj1 + curj2, jug1, jug2, target, depth + 1, maxDepth);
            } else {
                temp = solveDfs(curj1 - (jug2 - curj2), jug2, jug1, jug2, target, depth + 1, maxDepth);
            }
            if (temp) {
                result.add(new Node(curj1, curj2));
                return true;
            }
        }

        // Transfer from jug2 to jug1
        if (curj2 > 0 && curj1 < jug1) {
            boolean temp;
            if (curj1 + curj2 <= jug1) {
                temp = solveDfs(curj1 + curj2, 0, jug1, jug2, target, depth + 1, maxDepth);
            } else {
                temp = solveDfs(jug1, curj2 - (jug1 - curj1), jug1, jug2, target, depth + 1, maxDepth);
            }
            if (temp) {
                result.add(new Node(curj1, curj2));
                return true;
            }
        }

        vis[curj1][curj2] = false;
        return false;
    }

    static boolean iddfs(int jug1, int jug2, int target, int maxDepth) {
        for (int depth = 0; depth <= maxDepth; depth++) {
            // Reset visited array and result stack for each iteration
            for (int i = 0; i < vis.length; i++) {
                Arrays.fill(vis[i], false);
            }
            result.clear();

            if (solveDfs(0, 0, jug1, jug2, target, 0, depth)) {
                return true;
            }
        }
        return false;
    }

    public static void printReverseStack(Stack<Node> stack) {
        if (stack.isEmpty()) {
            return;
        }
        Stack<Node> tempStack = new Stack<>();

        while (!stack.isEmpty()) {
            tempStack.push(stack.pop());
        }

        while (!tempStack.isEmpty()) {
            Node n = tempStack.pop();
            System.out.println("(" + n.x + "," + n.y + ")");
            stack.push(n); // Push back to the original stack to maintain order
        }
    }

    public static void main(String[] args) {
        int maxDepth = 10; // Adjust this as needed
        boolean res = iddfs(4, 3, 2, maxDepth);
        printReverseStack(result);
        System.out.println("Total steps: " + total);
    }
}

*****************************depth dfs***********************************
import java.util.*;

public class dfs {

    public static int total = 0;

    static class Node {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static Stack<Node> result = new Stack<>();
    static boolean vis[][] = new boolean[5][5];

    static boolean solveDfs(int curj1, int curj2, int jug1, int jug2, int target, int depth, int maxDepth) {
        if (depth > maxDepth) {
            return false;
        }

        if (curj1 == target || curj2 == target) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        if (vis[curj1][curj2]) {
            return false;
        }

        vis[curj1][curj2] = true;
        total++;

        // Try all possible moves

        // Fill jug1
        if (curj1 < jug1 && solveDfs(jug1, curj2, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Fill jug2
        if (curj2 < jug2 && solveDfs(curj1, jug2, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Empty jug1
        if (curj1 > 0 && solveDfs(0, curj2, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Empty jug2
        if (curj2 > 0 && solveDfs(curj1, 0, jug1, jug2, target, depth + 1, maxDepth)) {
            result.add(new Node(curj1, curj2));
            return true;
        }

        // Transfer from jug1 to jug2
        if (curj1 > 0 && curj2 < jug2) {
            boolean temp;
            if (curj1 + curj2 <= jug2) {
                temp = solveDfs(0, curj1 + curj2, jug1, jug2, target, depth + 1, maxDepth);
            } else {
                temp = solveDfs(curj1 - (jug2 - curj2), jug2, jug1, jug2, target, depth + 1, maxDepth);
            }
            if (temp) {
                result.add(new Node(curj1, curj2));
                return true;
            }
        }

        // Transfer from jug2 to jug1
        if (curj2 > 0 && curj1 < jug1) {
            boolean temp;
            if (curj1 + curj2 <= jug1) {
                temp = solveDfs(curj1 + curj2, 0, jug1, jug2, target, depth + 1, maxDepth);
            } else {
                temp = solveDfs(jug1, curj2 - (jug1 - curj1), jug1, jug2, target, depth + 1, maxDepth);
            }
            if (temp) {
                result.add(new Node(curj1, curj2));
                return true;
            }
        }

        vis[curj1][curj2] = false;
        return false;
    }

    public static void printReverseStack(Stack<Node> stack) {
        if (stack.isEmpty()) {
            return;
        }
        Stack<Node> tempStack = new Stack<>();

        while (!stack.isEmpty()) {
            tempStack.push(stack.pop());
        }

        while (!tempStack.isEmpty()) {
            Node n = tempStack.pop();
            System.out.println("(" + n.x + "," + n.y + ")");
            stack.push(n); // Push back to the original stack to maintain order
        }
    }

    public static void main(String[] args) {
        int maxDepth = 10; // Adjust this as needed
        boolean res = solveDfs(0, 0, 4, 3, 2, 0, maxDepth);
        printReverseStack(result);
        System.out.println("Total steps: " + total);
    }
}


************Hill climbing*************
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class Point {
    int x, y, n;

    Point(int x, int y, int n) {
        this.x = x;
        this.y = y;
        this.n = n;
    }

    int manhattan(Point other) {
        return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);
    }

    List<Point> generateCentre() {
        List<Point> centres = new ArrayList<>();
        int[][] directions = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
        for (int[] d : directions) {
            int newX = this.x + d[0];
            int newY = this.y + d[1];
            if (newX >= 0 && newX <= n && newY >= 0 && newY <= n) {
                centres.add(new Point(newX, newY, n));
            }
        }
        return centres;
    }

    @Override
    public String toString() {
        return "(x, y) = (" + x + ", " + y + ")";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Point point = (Point) obj;
        return x == point.x && y == point.y;
    }

    @Override
    public int hashCode() {
        return 31 * x + y;
    }
}

public class ManhattanCentre {
    static Set<Point> visited = new HashSet<>();

    public static void main(String[] args) {
        int n = 9;  // Grid dimension

        // Hardcoded coordinates of points
        int[][] coordinates = {
            {1, 1},
            {9, 4},
            {4, 6},
            {2, 5},
            {7, 7}
        };

        List<Point> pointsList = new ArrayList<>();
        for (int[] coordinate : coordinates) {
            pointsList.add(new Point(coordinate[0], coordinate[1], n));
        }

        Point initialCentre = new Point(0, 0, n);
        findCentre(pointsList, n, initialCentre);
    }

    static void findCentre(List<Point> pointsList, int n, Point centre) {
        visited.add(centre);
        System.out.println("\n--------------------------------------------------------------");
        System.out.println("Current centre: " + centre);
        System.out.println("Sum of manhattan distances (centre) :" + sum(pointsList, centre));

        List<Point> newCentres = centre.generateCentre();
        newCentres.removeAll(visited);  // Remove already visited centres

        System.out.println("\nNew centres: ");
        for (Point pt : newCentres) {
            System.out.println(pt);
        }

        List<Integer> distances = new ArrayList<>();
        for (Point pt : newCentres) {
            distances.add(sum(pointsList, pt));
        }

        System.out.println("Sum of manhattan distances from new centres: " + distances);

        int currentSum = sum(pointsList, centre);
        if (!distances.isEmpty()) {
            int minDistance = distances.stream().min(Integer::compareTo).orElse(currentSum);
            if (minDistance < currentSum) {
                Point newCentre = newCentres.get(distances.indexOf(minDistance));
                findCentre(pointsList, n, newCentre);
            } else {
                System.out.println("Finalized Minimal centre: " + centre);
                System.out.println("Cost: " + currentSum);
            }
        } else {
            System.out.println("Finalized Minimal centre: " + centre);
            System.out.println("Cost: " + currentSum);
        }
    }

    static int sum(List<Point> pointsList, Point centre) {
        return pointsList.stream().mapToInt(pt -> centre.manhattan(pt)).sum();
    }
}


//AO* cpp
#include <iostream>
#include <map>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

map<string, int> cost(map<string, int>& H, map<string, vector<string>>& condition, int weight) {
    map<string, int> cost;
    if (condition.count("AND")) {
        vector<string> AND_nodes = condition["AND"];
        string Path_A = AND_nodes[0];
        for (int i = 1; i < AND_nodes.size(); i++) {
            Path_A += " AND " + AND_nodes[i];
        }
        int PathA = 0;
        for (string node : AND_nodes) {
            PathA += H[node] + weight;
        }
        cost[Path_A] = PathA;
        cout << Path_A << ": " << H[Path_A] << " >>> {";
        for (string node : AND_nodes) {
            cout << node << "=" << H[node] << ", ";
        }
        cout << Path_A << "=" << PathA << "}" << endl;
    }
    if (condition.count("OR")) {
        vector<string> OR_nodes = condition["OR"];
        string Path_B = OR_nodes[0];
        for (int i = 1; i < OR_nodes.size(); i++) {
            Path_B += " OR " + OR_nodes[i];
        }
        int PathB = INT_MAX;
        for (string node : OR_nodes) {
            PathB = min(PathB, H[node] + weight);
        }
        cost[Path_B] = PathB;
        cout << Path_B << ": " << H[Path_B] << " >>> {";
        for (string node : OR_nodes) {
            cout << node << "=" << H[node] << ", ";
        }
        cout << Path_B << "=" << PathB << "}" << endl;
    }
    return cost;
}

map<string, map<string, int>> updateCost(map<string, int>& H, map<string, map<string, vector<string>>>& conditions, int weight) {
    vector<string> Main_nodes(conditions.size());
    int i = 0;
    for (auto it = conditions.rbegin(); it != conditions.rend(); it++) {
        Main_nodes[i++] = it->first;
    }
    map<string, map<string, int>> least_cost;
    for (string key : Main_nodes) {
        map<string, vector<string>> condition = conditions[key];
        map<string, int> c = cost(H, condition, weight);
        auto it = min_element(c.begin(), c.end(), [](const pair<string, int>& p1, const pair<string, int>& p2) {return p1.second < p2.second;});
        H[key] = it->second;
        least_cost[key] = cost(H, condition, weight);
    }
    return least_cost;
}

string shortestPath(string Start, map<string, map<string, int>>& Updated_cost, map<string, int>& H) {
    string Path = Start;
    if (Updated_cost.count(Start)) {
        auto it = min_element(Updated_cost[Start].begin(), Updated_cost[Start].end(), [](const pair<string, int>& p1, const pair<string, int>& p2) {return p1.second < p2.second;});
        int Min_cost = it->second;
        vector<string> key(Updated_cost[Start].size());
        vector<int> values(Updated_cost[Start].size());
        int i = 0;
        for (auto it = Updated_cost[Start].begin(); it != Updated_cost[Start].end(); it++) {
            key[i] = it->first;
            values[i++] = it->second;
        }
        int Index = find(values.begin(), values.end(), Min_cost) - values.begin();
        vector<string> Next;
        string temp = "";
        for (char ch : key[Index]) {
            if (ch == ' ') {
                if (temp != "AND" && temp != "OR") {
                    Next.push_back(temp);
                }
                temp = "";
            } else {
                temp += ch;
            }
        }
        if (temp != "AND" && temp != "OR") {
            Next.push_back(temp);
        }
        if (Next.size() == 1) {
            Start = Next[0];
            Path += "<--" + shortestPath(Start, Updated_cost, H);
        } else {
            Path += "<--(" + key[Index] + ") ";
            Start = Next[0];
            Path += "[" + shortestPath(Start, Updated_cost, H) + " + ";
            Start = Next[Next.size() - 1];
            Path += shortestPath(Start, Updated_cost, H) + "]";
        }
    }
    return Path;
}

int main() {
    map<string, int> H = {{"A", -1}, {"B", 5}, {"C", 2}, {"D", 4}, {"E", 7}, {"F", 9}, {"G", 3}, {"H", 0}, {"I", 0}, {"J", 0}};
    map<string, map<string, vector<string>>> conditions;
    conditions["A"] = {{"OR", {"B"}}, {"AND", {"C", "D"}}};
    conditions["B"] = {{"OR", {"E", "F"}}};
    conditions["C"] = {{"OR", {"G"}}, {"AND", {"H", "I"}}};
    conditions["D"] = {{"OR", {"J"}}};
    int weight = 1;
    cout << "Updated Cost :" << endl;
    map<string, map<string, int>> Updated_cost = updateCost(H, conditions, weight);
    cout << string(75, '*') << endl;
    cout << "Shortest Path :" << endl;
    cout << shortestPath("A", Updated_cost, H) << endl;
    return 0;
}

//Hill Climbing cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;

struct Puzzle {
    vector<vector<int>> board;
    int empty_x, empty_y;
    int cost;

    Puzzle(vector<vector<int>> b, int ex, int ey) : board(b), empty_x(ex), empty_y(ey) {
        cost = heuristic();
    }

    int heuristic() const {
        // Manhattan distance
        int h = 0;
        int goal[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                int value = board[i][j];
                if (value != 0) {
                    int goal_x = (value - 1) / 3;
                    int goal_y = (value - 1) % 3;
                    h += abs(i - goal_x) + abs(j - goal_y);
                }
            }
        }
        return h;
    }

    bool operator<(const Puzzle& other) const {
        return cost > other.cost;
    }

    bool isGoal() const {
        int goal[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 0} };
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                if (board[i][j] != goal[i][j]) return false;
            }
        }
        return true;
    }

    void printBoard() const {
        for (const auto& row : board) {
            for (int cell : row) {
                cout << cell << " ";
            }
            cout << endl;
        }
        cout << "Heuristic Cost: " << cost << endl;
    }

    vector<Puzzle> getNeighbors() const {
        vector<Puzzle> neighbors;
        vector<pair<int, int>> directions = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };

        for (const auto& dir : directions) {
            int new_x = empty_x + dir.first;
            int new_y = empty_y + dir.second;

            if (new_x >= 0 && new_x < 3 && new_y >= 0 && new_y < 3) {
                vector<vector<int>> new_board = board;
                swap(new_board[empty_x][empty_y], new_board[new_x][new_y]);
                neighbors.push_back(Puzzle(new_board, new_x, new_y));
            }
        }
        return neighbors;
    }
};

Puzzle hillClimbing(Puzzle start) {
    Puzzle current = start;
    cout << "Initial Board:" << endl;
    current.printBoard();

    while (true) {
        vector<Puzzle> neighbors = current.getNeighbors();
        Puzzle bestNeighbor = current;

        for (const auto& neighbor : neighbors) {
            if (neighbor.cost < bestNeighbor.cost) {
                bestNeighbor = neighbor;
            }
        }

        if (bestNeighbor.cost >= current.cost) {
            break;
        }

        current = bestNeighbor;
        cout << "\nNext Board:" << endl;
        current.printBoard();
    }

    return current;
}

int main() {
    vector<vector<int>> startBoard = {
        {2, 8, 3},
        {1, 6, 4},
        {7, 0, 5}
    };

    int empty_x = 2, empty_y = 1; // Position of the empty tile (0)

    Puzzle start(startBoard, empty_x, empty_y);

    Puzzle result = hillClimbing(start);

    cout << "\nFinal Board:" << endl;
    result.printBoard();

    if (result.isGoal()) {
        cout << "Goal state reached!" << endl;
    } else {
        cout << "Failed to reach goal state." << endl;
    }

    return 0;
}

//A* romania
#include <iostream>
#include <vector>
#include <map>
#include <queue>
#include <string>
#include <algorithm>
#include <functional>

using namespace std;

// Define the cities and their connections
map<string, map<string, int>> graph = {
    {"A", {{"B", 2}, {"C", 4}}},
    {"B", {{"A", 4}, {"D", 3}, {"E", 1}}},
    {"C", {{"A", 2}, {"F", 5}}},
    {"D", {{"B", 3}, {"G", 7}}},
    {"E", {{"B", 1}, {"G", 2}}},
    {"F", {{"C", 4}, {"G", 1}}},
    {"G", {{"D", 7}, {"E", 1}, {"F", 1}}}};

// Heuristic function (straight-line distance to Bucharest)
map<string, int> heuristic = {
    {"A", 6}, {"B", 4}, {"C", 3}, {"D", 4}, {"E", 2}, {"F", 1}, {"G", 0}};

// A* Search function
vector<string> aStarSearch(const string &start, const string &goal)
{
    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> frontier;
    map<string, string> cameFrom; // to keep track of the parent node for each node encountered during the search
    map<string, int> costSoFar;

    frontier.push({heuristic[start], start});
    cameFrom[start] = "";
    costSoFar[start] = 0;

    while (!frontier.empty())
    {
        string current = frontier.top().second;
        frontier.pop();

        if (current == goal)
        {
            vector<string> path;
            while (current != "")
            {
                path.push_back(current);
                current = cameFrom[current];
            }
            reverse(path.begin(), path.end());
            return path;
        }

        for (const auto &neighbor : graph[current])
        {
            string next = neighbor.first;
            int newCost = costSoFar[current] + neighbor.second; // total cost of reaching the neighboring node as per graph

            if (costSoFar.find(next) == costSoFar.end())
            { // if next has not been visited or if the new cost to reach next is lower than the previously recorded cost
                costSoFar[next] = newCost;
                cameFrom[next] = current;
                int priority = newCost + heuristic[next];
                frontier.push({priority, next});
            }
        }
    }

    return {}; // No path found
}

int main()
{
    string start = "A";
    string goal = "G";

    vector<string> path = aStarSearch(start, goal);

    if (!path.empty())
    {
        cout << "Shortest path from " << start << " to " << goal << ":\n";
        for (const string &city : path)
        {
            cout << city;
            if (city != goal)
            {
                cout << " -> ";
            }
        }
        cout << "\nGoal reached.\n";
    }
    else
    {
        cout << "No path found from " << start << " to " << goal << ".\n";
    }

    return 0;
}

//p1
move(state(middle,onbox,middle,hasnot),
   grasp,
   state(middle,onbox,middle,has)).
move(state(P,onfloor,P,H),
   climb,
   state(P,onbox,P,H)).
move(state(P1,onfloor,P1,H),
   drag(P1,P2),
   state(P2,onfloor,P2,H)).
move(state(P1,onfloor,B,H),
   walk(P1,P2),
   state(P2,onfloor,B,H)).
canget(state(_,_,_,has)).
canget(State1) :-
   move(State1,_,State2),
   canget(State2).
   
//p2
% Initial state
at(monkey, room).
at(chair, room).
at(stick, room).
at(bananas, ceiling).

% Define actions
% Monkey can move from one place to another
move(From, To, Object) :-
    at(Object, From),
    retract(at(Object, From)),
    assert(at(Object, To)).

% Monkey can climb on the chair
climb_on_chair :-
    at(monkey, room),
    at(chair, room),
    move(room, chair, monkey).

% Monkey can reach the bananas with the stick
reach_bananas :-
    at(monkey, chair),
    at(stick, monkey),
    at(bananas, ceiling).

% Solve the problem
solve :-
    climb_on_chair,
    reach_bananas,
    write('Monkey has the bananas!').

% Example query to solve the problem
% ?- solve.

//p3
% Dynamic facts to represent the state
:- dynamic at/2, has/1.

% Initial state of the monkey and bananas
at(monkey, floor).
at(box, floor).
at(bananas, ceiling).
has(bananas) :- false.

% Actions that the monkey can perform
% The monkey can climb the box
climb_box :-
    at(monkey, floor),
    at(box, floor),
    retract(at(monkey, floor)),
    assert(at(monkey, box)),
    write('Monkey climbs the box.'), nl.

% The monkey can grasp the bananas
grasp_bananas :-
    at(monkey, box),
    at(bananas, ceiling),
    retract(at(bananas, ceiling)),
    assert(has(bananas)),
    write('Monkey grasps the bananas.'), nl.

% Define the goal
goal :- has(bananas).

% Move function to achieve the goal
move :-
    goal,
    write('Goal achieved!'), nl.

move :-
    \+ goal,
    (climb_box ; grasp_bananas),
    move.

% Example query to run the program
% To see if the monkey can achieve the goal, run:
% ?- move.

//p5
% Define the symptoms for each condition
symptom(cold, sneezing).
symptom(cold, runny_nose).
symptom(cold, cough).
symptom(flu, fever).
symptom(flu, chills).
symptom(flu, fatigue).
symptom(allergies, itchy_eyes).
symptom(allergies, sneezing).
symptom(allergies, runny_nose).

% Define rules for diagnosing the conditions based on symptoms
diagnose(X, cold) :- 
    symptom(X, sneezing),
    symptom(X, runny_nose),
    symptom(X, cough).

diagnose(X, flu) :- 
    symptom(X, fever),
    symptom(X, chills),
    symptom(X, fatigue).

diagnose(X, allergies) :- 
    symptom(X, itchy_eyes),
    symptom(X, sneezing),
    symptom(X, runny_nose).

% Query to diagnose a condition based on symptoms
diagnose_condition(Symptoms, Condition) :-
    findall(X, (member(Symptom, Symptoms), diagnose(Symptom, X)), Conditions),
    list_to_set(Conditions, UniqueConditions),
    length(UniqueConditions, NumConditions),
    NumConditions = 1,
    nth0(0, UniqueConditions, Condition).

% Example usage:
% diagnose_condition([fever, chills, fatigue], Condition).

//p6
% Define medical conditions and their associated symptoms
has_symptom(john, fever).
has_symptom(john, headache).
has_symptom(mary, cough).
has_symptom(mary, fatigue).
has_symptom(jane, cough).
has_symptom(jane, fatigue).


% Define rules for diagnosing medical conditions
diagnose_patient(Patient, Condition) :-
    has_symptom(Patient, fever),
    has_symptom(Patient, headache),
    Condition = flu.
diagnose_patient(Patient, Condition) :-
    has_symptom(Patient, cough),
    has_symptom(Patient, fatigue),
    Condition = common_cold.
diagnose_patient(_, unknown).

% Query the expert system to diagnose patients
?- diagnose_patient(john, X).
?- diagnose_patient(jane, X).

//p7
destination(mumbai, asia, culture, beach, summer).
destination(paris, europe, culture, moderate, spring).
destination(tokyo, asia, culture, expensive, spring).
destination(new_york, north_america, shopping, expensive, autumn).
destination(dubai, middle_east, luxury, expensive, winter).
destination(bangkok, asia, beach, moderate, summer).
destination(rio_de_janeiro, south_america, beach, moderate, summer).
destination(london, europe, culture, moderate, summer).
destination(rome, europe, culture, moderate, spring).
destination(sydney, australia, beach, expensive, summer).
destination(amsterdam, europe, culture, moderate, spring).
destination(hong_kong, asia, shopping, expensive, autumn).
destination(cancun, north_america, beach, moderate, summer).
destination(cairo, africa, culture, cheap, spring).
destination(cape_town, africa, beach, moderate, summer).
destination(mexico_city, north_america, culture, cheap, autumn).
destination(moscow, europe, culture, moderate, winter).
destination(athens, europe, culture, moderate, summer).
destination(istanbul, europe, culture, moderate, spring).
destination(mumbai, asia, culture, cheap, winter).
destination(seoul, asia, culture, moderate, autumn).
destination(bali, asia, beach, moderate, summer).

recommend(Destination, Budget, Interest, Weather) :-
    destination(Destination, _, Interest, Budget, Weather).

start :- 
    write('Welcome to Travel Planner'), nl,
    ask_budget(Budget),
    ask_interest(Interest),
    ask_weather(Weather),
    findall(Destination, recommend(Destination, Budget, Interest, Weather), Destinations),
    display(Destinations).

ask_budget(Budget):-
    write("what is ur budget"), nl,
    read(Budget).

ask_interest(Interest):-
    write("what is ur interest"), nl,
    read(Interest).

ask_weather(Weather):-
    write("what is ur preferred weather"), nl,
    read(Weather).

display([]):-
    write("No recommendations"), nl.

display(Destinations) :- 
    write("Recommendations:"), nl,
    display_list(Destinations).

display_list([]).
    display_list([H|T]):-
    write(' - '), write(H), nl, display_list(T).
    
//p8
% Knowledge Base
destination(paris, europe, culture, moderate, spring).
destination(tokyo, asia, culture, expensive, spring).
destination(new_york, north_america, shopping, expensive, autumn).
destination(dubai, middle_east, luxury, expensive, winter).
destination(bangkok, asia, beach, moderate, summer).
destination(rio_de_janeiro, south_america, beach, moderate, summer).
destination(london, europe, culture, moderate, summer).
destination(rome, europe, culture, moderate, spring).
destination(sydney, australia, beach, expensive, summer).
destination(amsterdam, europe, culture, moderate, spring).
destination(hong_kong, asia, shopping, expensive, autumn).
destination(cancun, north_america, beach, moderate, summer).
destination(cairo, africa, culture, cheap, spring).
destination(cape_town, africa, beach, moderate, summer).
destination(mexico_city, north_america, culture, cheap, autumn).
destination(moscow, europe, culture, moderate, winter).
destination(athens, europe, culture, moderate, summer).
destination(istanbul, europe, culture, moderate, spring).
destination(mumbai, asia, culture, cheap, winter).
destination(seoul, asia, culture, moderate, autumn).
destination(bali, asia, beach, moderate, summer).

% Rules
recommend(Destination, Interest, Budget, Weather):-
    destination(Destination, _, Interest, Budget, Weather).

% User Interface
start:-
    write("Welcome to travel"), nl,
    write("Please answer the following questions for recommendation."), nl, 
    ask_budget(Budget),
    ask_interest(Interest),
    ask_weather(Weather),
    findall(Destination, recommend(Destination, Interest, Budget, Weather), Destinations),
    display(Destinations).

ask_budget(Budget):-
    write("What's your budget? "), nl,
    read(Budget).

ask_interest(Interest):-
    write("What's your interest? "), nl,
    read(Interest).

ask_weather(Weather):-
    write("What weather do u like? "), nl,
    read(Weather).

display([]):-
    write("No recommendations"), nl.

display(Destinations) :- 
    write("Recommendations:"), nl,
    display_list(Destinations).

display_list([]).
display_list([H|T]):-
    write("- "), write(H), nl,
    display_list(T).
